
Color Sensor Demo Code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800200  00800200  00000326  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000002b2  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000008  00800200  00800200  00000326  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000326  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000358  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000088  00000000  00000000  00000398  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000f1b  00000000  00000000  00000420  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000c67  00000000  00000000  0000133b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000054d  00000000  00000000  00001fa2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000108  00000000  00000000  000024f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000688  00000000  00000000  000025f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000121  00000000  00000000  00002c80  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  00002da1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 9e 00 	jmp	0x13c	; 0x13c <__vector_1>
   8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
   c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  10:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  14:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  18:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  1c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  20:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  24:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  28:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  2c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  30:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  34:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  38:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  3c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  40:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  44:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  48:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  4c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  50:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  54:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  58:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  5c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  60:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  64:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  68:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  6c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  70:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  74:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  78:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  7c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  80:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  84:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  88:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  8c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  90:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  94:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  98:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  9c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  a0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  a4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  a8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  ac:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  b0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  b4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  b8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  bc:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  c0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  c4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  c8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  cc:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  d0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  d4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  d8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  dc:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  e0:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_clear_bss>:
  f4:	22 e0       	ldi	r18, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	01 c0       	rjmp	.+2      	; 0xfe <.do_clear_bss_start>

000000fc <.do_clear_bss_loop>:
  fc:	1d 92       	st	X+, r1

000000fe <.do_clear_bss_start>:
  fe:	a8 30       	cpi	r26, 0x08	; 8
 100:	b2 07       	cpc	r27, r18
 102:	e1 f7       	brne	.-8      	; 0xfc <.do_clear_bss_loop>
 104:	0e 94 14 01 	call	0x228	; 0x228 <main>
 108:	0c 94 57 01 	jmp	0x2ae	; 0x2ae <_exit>

0000010c <__bad_interrupt>:
 10c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000110 <rgb_port_config>:
{
	// Filter Select - no filter
	// set S3 Low
	// set S2 High
	PORTB &=~  0x08;   
	PORTB |=   0x04;   
 110:	81 b1       	in	r24, 0x01	; 1
 112:	87 60       	ori	r24, 0x07	; 7
 114:	81 b9       	out	0x01, r24	; 1
 116:	82 b1       	in	r24, 0x02	; 2
 118:	88 7f       	andi	r24, 0xF8	; 248
 11a:	82 b9       	out	0x02, r24	; 2
 11c:	08 95       	ret

0000011e <color_sensor_pin_config>:
 11e:	50 98       	cbi	0x0a, 0	; 10
 120:	84 b1       	in	r24, 0x04	; 4
 122:	8f 60       	ori	r24, 0x0F	; 15
 124:	84 b9       	out	0x04, r24	; 4
 126:	58 9a       	sbi	0x0b, 0	; 11
 128:	08 95       	ret

0000012a <color_sensor_pin_interrupt_init>:
 12a:	f8 94       	cli
 12c:	e9 e6       	ldi	r30, 0x69	; 105
 12e:	f0 e0       	ldi	r31, 0x00	; 0
 130:	80 81       	ld	r24, Z
 132:	82 60       	ori	r24, 0x02	; 2
 134:	80 83       	st	Z, r24
 136:	e8 9a       	sbi	0x1d, 0	; 29
 138:	78 94       	sei
 13a:	08 95       	ret

0000013c <__vector_1>:
 13c:	1f 92       	push	r1
 13e:	0f 92       	push	r0
 140:	0f b6       	in	r0, 0x3f	; 63
 142:	0f 92       	push	r0
 144:	11 24       	eor	r1, r1
 146:	8f 93       	push	r24
 148:	9f 93       	push	r25
 14a:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 14e:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 152:	01 96       	adiw	r24, 0x01	; 1
 154:	90 93 07 02 	sts	0x0207, r25	; 0x800207 <pulse+0x1>
 158:	80 93 06 02 	sts	0x0206, r24	; 0x800206 <pulse>
 15c:	9f 91       	pop	r25
 15e:	8f 91       	pop	r24
 160:	0f 90       	pop	r0
 162:	0f be       	out	0x3f, r0	; 63
 164:	0f 90       	pop	r0
 166:	1f 90       	pop	r1
 168:	18 95       	reti

0000016a <init_devices>:
 16a:	f8 94       	cli
 16c:	0e 94 88 00 	call	0x110	; 0x110 <rgb_port_config>
 170:	0e 94 8f 00 	call	0x11e	; 0x11e <color_sensor_pin_config>
 174:	0e 94 95 00 	call	0x12a	; 0x12a <color_sensor_pin_interrupt_init>
 178:	78 94       	sei
 17a:	08 95       	ret

0000017c <filter_red>:
 17c:	85 b1       	in	r24, 0x05	; 5
 17e:	83 7f       	andi	r24, 0xF3	; 243
 180:	85 b9       	out	0x05, r24	; 5
 182:	08 95       	ret

00000184 <filter_green>:
 184:	85 b1       	in	r24, 0x05	; 5
 186:	8c 60       	ori	r24, 0x0C	; 12
 188:	85 b9       	out	0x05, r24	; 5
 18a:	08 95       	ret

0000018c <filter_blue>:
 18c:	2b 9a       	sbi	0x05, 3	; 5
 18e:	2a 98       	cbi	0x05, 2	; 5
 190:	08 95       	ret

00000192 <color_sensor_scaling>:
void color_sensor_scaling()	// This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	// Output Scaling 20% from datasheet
	// set S1 high
	// set S0 high
	PORTB |= 0x02;    
 192:	29 9a       	sbi	0x05, 1	; 5
	PORTB |= 0x01;    
 194:	28 9a       	sbi	0x05, 0	; 5
 196:	08 95       	ret

00000198 <red_read>:
}

void red_read(void)	// function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	// Red
	filter_red();			// select red filter
 198:	0e 94 be 00 	call	0x17c	; 0x17c <filter_red>
	pulse = 0;				// reset the count to 0
 19c:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <pulse+0x1>
 1a0:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <pulse>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1a4:	2f ef       	ldi	r18, 0xFF	; 255
 1a6:	81 ee       	ldi	r24, 0xE1	; 225
 1a8:	94 e0       	ldi	r25, 0x04	; 4
 1aa:	21 50       	subi	r18, 0x01	; 1
 1ac:	80 40       	sbci	r24, 0x00	; 0
 1ae:	90 40       	sbci	r25, 0x00	; 0
 1b0:	e1 f7       	brne	.-8      	; 0x1aa <red_read+0x12>
 1b2:	00 c0       	rjmp	.+0      	; 0x1b4 <red_read+0x1c>
 1b4:	00 00       	nop
	_delay_ms(100);			// capture the pulses for 100 ms or 0.1 second
	red = pulse;			// store the count in variable called red
 1b6:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 1ba:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 1be:	90 93 05 02 	sts	0x0205, r25	; 0x800205 <red+0x1>
 1c2:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <red>
 1c6:	08 95       	ret

000001c8 <green_read>:
}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	// Green
	filter_green();			// select green filter
 1c8:	0e 94 c2 00 	call	0x184	; 0x184 <filter_green>
	pulse = 0;				// reset the count to 0
 1cc:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <pulse+0x1>
 1d0:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <pulse>
 1d4:	2f ef       	ldi	r18, 0xFF	; 255
 1d6:	81 ee       	ldi	r24, 0xE1	; 225
 1d8:	94 e0       	ldi	r25, 0x04	; 4
 1da:	21 50       	subi	r18, 0x01	; 1
 1dc:	80 40       	sbci	r24, 0x00	; 0
 1de:	90 40       	sbci	r25, 0x00	; 0
 1e0:	e1 f7       	brne	.-8      	; 0x1da <green_read+0x12>
 1e2:	00 c0       	rjmp	.+0      	; 0x1e4 <green_read+0x1c>
 1e4:	00 00       	nop
	_delay_ms(100);			// capture the pulses for 100 ms or 0.1 second
	green = pulse;			// store the count in variable called green
 1e6:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 1ea:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 1ee:	90 93 03 02 	sts	0x0203, r25	; 0x800203 <green+0x1>
 1f2:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <green>
 1f6:	08 95       	ret

000001f8 <blue_read>:
}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	// Blue
	filter_blue();			// select blue filter
 1f8:	0e 94 c6 00 	call	0x18c	; 0x18c <filter_blue>
	pulse = 0;				// reset the count to 0
 1fc:	10 92 07 02 	sts	0x0207, r1	; 0x800207 <pulse+0x1>
 200:	10 92 06 02 	sts	0x0206, r1	; 0x800206 <pulse>
 204:	2f ef       	ldi	r18, 0xFF	; 255
 206:	81 ee       	ldi	r24, 0xE1	; 225
 208:	94 e0       	ldi	r25, 0x04	; 4
 20a:	21 50       	subi	r18, 0x01	; 1
 20c:	80 40       	sbci	r24, 0x00	; 0
 20e:	90 40       	sbci	r25, 0x00	; 0
 210:	e1 f7       	brne	.-8      	; 0x20a <blue_read+0x12>
 212:	00 c0       	rjmp	.+0      	; 0x214 <blue_read+0x1c>
 214:	00 00       	nop
	_delay_ms(100);			// capture the pulses for 100 ms or 0.1 second
	blue = pulse;			// store the count in variable called blue  
 216:	80 91 06 02 	lds	r24, 0x0206	; 0x800206 <pulse>
 21a:	90 91 07 02 	lds	r25, 0x0207	; 0x800207 <pulse+0x1>
 21e:	90 93 01 02 	sts	0x0201, r25	; 0x800201 <_edata+0x1>
 222:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <_edata>
 226:	08 95       	ret

00000228 <main>:
}

int main(void)
{
	init_devices();
 228:	0e 94 b5 00 	call	0x16a	; 0x16a <init_devices>
	color_sensor_scaling();
 22c:	0e 94 c9 00 	call	0x192	; 0x192 <color_sensor_scaling>
		{
			PORTA = 0x03;				// Glow only BLUE
		}
		else
		{
			PORTA = 0x05;				// Glow only GREEN
 230:	15 e0       	ldi	r17, 0x05	; 5
				PORTA = 0x03;			// Glow only BLUE
			}
		}
		else if(blue > green)
		{
			PORTA = 0x03;				// Glow only BLUE
 232:	c3 e0       	ldi	r28, 0x03	; 3
		}
		else if(red > green)
		{
			if(red > blue)
			{
				PORTA = 0x06;			// Glow only RED
 234:	d6 e0       	ldi	r29, 0x06	; 6
		red_read();
		green_read();
		blue_read();
		if((red < 3000) && (blue < 3000) && (green < 3000))
		{
			PORTA = 0x07;				// Switch off RGB LED in case of black detection
 236:	07 e0       	ldi	r16, 0x07	; 7
	color_sensor_scaling();
  
	while(1)
	{
		// Write your code here
		red_read();
 238:	0e 94 cc 00 	call	0x198	; 0x198 <red_read>
		green_read();
 23c:	0e 94 e4 00 	call	0x1c8	; 0x1c8 <green_read>
		blue_read();
 240:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <blue_read>
		if((red < 3000) && (blue < 3000) && (green < 3000))
 244:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <red>
 248:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <red+0x1>
 24c:	88 3b       	cpi	r24, 0xB8	; 184
 24e:	2b e0       	ldi	r18, 0x0B	; 11
 250:	92 07       	cpc	r25, r18
 252:	84 f4       	brge	.+32     	; 0x274 <main+0x4c>
 254:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <_edata>
 258:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <_edata+0x1>
 25c:	28 3b       	cpi	r18, 0xB8	; 184
 25e:	3b 40       	sbci	r19, 0x0B	; 11
 260:	4c f4       	brge	.+18     	; 0x274 <main+0x4c>
 262:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <green>
 266:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <green+0x1>
 26a:	28 3b       	cpi	r18, 0xB8	; 184
 26c:	3b 40       	sbci	r19, 0x0B	; 11
 26e:	14 f4       	brge	.+4      	; 0x274 <main+0x4c>
		{
			PORTA = 0x07;				// Switch off RGB LED in case of black detection
 270:	02 b9       	out	0x02, r16	; 2
 272:	e2 cf       	rjmp	.-60     	; 0x238 <main+0x10>
		}
		else if(red > green)
 274:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <green>
 278:	30 91 03 02 	lds	r19, 0x0203	; 0x800203 <green+0x1>
 27c:	28 17       	cp	r18, r24
 27e:	39 07       	cpc	r19, r25
 280:	5c f4       	brge	.+22     	; 0x298 <main+0x70>
		{
			if(red > blue)
 282:	20 91 00 02 	lds	r18, 0x0200	; 0x800200 <_edata>
 286:	30 91 01 02 	lds	r19, 0x0201	; 0x800201 <_edata+0x1>
 28a:	28 17       	cp	r18, r24
 28c:	39 07       	cpc	r19, r25
 28e:	14 f4       	brge	.+4      	; 0x294 <main+0x6c>
			{
				PORTA = 0x06;			// Glow only RED
 290:	d2 b9       	out	0x02, r29	; 2
 292:	d2 cf       	rjmp	.-92     	; 0x238 <main+0x10>
			}
			else
			{
				PORTA = 0x03;			// Glow only BLUE
 294:	c2 b9       	out	0x02, r28	; 2
 296:	d0 cf       	rjmp	.-96     	; 0x238 <main+0x10>
			}
		}
		else if(blue > green)
 298:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <_edata>
 29c:	90 91 01 02 	lds	r25, 0x0201	; 0x800201 <_edata+0x1>
 2a0:	28 17       	cp	r18, r24
 2a2:	39 07       	cpc	r19, r25
 2a4:	14 f4       	brge	.+4      	; 0x2aa <main+0x82>
		{
			PORTA = 0x03;				// Glow only BLUE
 2a6:	c2 b9       	out	0x02, r28	; 2
 2a8:	c7 cf       	rjmp	.-114    	; 0x238 <main+0x10>
		}
		else
		{
			PORTA = 0x05;				// Glow only GREEN
 2aa:	12 b9       	out	0x02, r17	; 2
 2ac:	c5 cf       	rjmp	.-118    	; 0x238 <main+0x10>

000002ae <_exit>:
 2ae:	f8 94       	cli

000002b0 <__stop_program>:
 2b0:	ff cf       	rjmp	.-2      	; 0x2b0 <__stop_program>
