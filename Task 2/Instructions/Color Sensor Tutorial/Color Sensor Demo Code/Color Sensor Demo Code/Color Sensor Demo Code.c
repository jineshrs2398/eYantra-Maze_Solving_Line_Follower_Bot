/*
*
* Team Id: 1508
* Author List: Gudapati Nitish, Deepak S V, Jinesh R, Himadri Poddar
* Filename: Color Sensor Demo Code.c
* Theme: Nutty Squirrel -- Specific to eYRC
* Functions: rgb_port_config (), color_sensor_pin_config(), color_sensor_pin_interrupt_init(), ISR(INT0_vect), init_devices(), filter_red(), filter_green(), filter_blue(), filter_clear(), color_sensor_scaling(), red_read(), green_read(), blue_read()
* Global Variables: pulse, red, green, blue 
*
*/

/*
 * Color_Sensor.c
 *
 * Created: 01-12-2018 14:45:11
 * Author: e-yantra Team
 
This experiment demonstrates the use of Color Sensor.

Micro-controller: atmega2560
Optimization: -O0  (For more information read section: Selecting proper optimization
options below figure 2.22 in the Software Manual)
*/

/*
*	Pins and Connections:
*		Red, Green, Blue LEDs -> PA0, PA1, PA2 (Digital Pins - 22, 23, 24) respectively 
*		Color Sensor: 
*			S0, S1, S2, S3 -> PB0, PB1, PB2, PB3 (Digital Pins - 50, 51, 52, 52) respectively
*			OUT -> PD0 (Pin - 21)
*/

#define F_CPU 16000000			// define F_CPU value
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h>				// included to support power function

// You can declare here global variable as per your requirement
int pulse = 0, red = 0, green = 0, blue = 0;	// pulse counters for red, green and blue

void rgb_port_config (void)
{
	/*****************************************
	Define DDR and PORT values for the port on which RGB LED is connected
	******************************************/
	DDRA  |=  0x07;
	PORTA &=~ 0x07;
}

void color_sensor_pin_config(void)
{
	/*****************************************
	Define DDR and PORT values for the port on which Color sensor is connected
	******************************************/
	DDRD &=~ 0x01;		// Set the direction of the PORTD pin 0 as input
	DDRB |= 0x0F;		// Set S0,S1,S2 & S3 as output pins
	PORTD |= 0x01;		// Enable internal pull-up for PORTD 0 pin
}


void color_sensor_pin_interrupt_init(void) // Interrupt 0 enable
{
	cli();				// Clears the global interrupt
	EICRA |= 0x02;		// INT0 is set to trigger with falling edge
	EIMSK |= 0x01;		// Enable Interrupt INT0 for color sensor
	sei();				// Enables the global interrupt
}

// ISR for color sensor
ISR(INT0_vect)	// Pass the timer number in place of n in INTn_vect
{
	// increment on receiving pulse from the color sensor
	pulse++;
}

void init_devices(void)
{
	cli();								// Clears the global interrupt
	rgb_port_config();					// Initialize all the ports here
	color_sensor_pin_config();            
	color_sensor_pin_interrupt_init();
	sei();								// Enables the global interrupt
}

// Filter Selection

void filter_red(void)	// Used to select red filter
{
	// Filter Select - red filter
	// set S2 low
	// set S3 low
	PORTB &=~ 0x0C;
}

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	//set S2 High
	//set S3 High
	PORTB |= 0x0C;
}

void filter_blue(void)	// Used to select blue filter
{
	// Filter Select - blue filter
	// set S3 High
	// set S2 low
	PORTB |=  0x08;   
	PORTB &=~ 0x04;   
}

void filter_clear(void)	// select no filter
{
	// Filter Select - no filter
	// set S3 Low
	// set S2 High
	PORTB &=~  0x08;   
	PORTB |=   0x04;   
}

// Color Sensing Scaling
void color_sensor_scaling()	// This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	// Output Scaling 20% from datasheet
	// set S1 high
	// set S0 high
	PORTB |= 0x02;    
	PORTB |= 0x01;    
}

void red_read(void)	// function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	// Red
	filter_red();			// select red filter
	pulse = 0;				// reset the count to 0
	_delay_ms(100);			// capture the pulses for 100 ms or 0.1 second
	red = pulse;			// store the count in variable called red
}

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	// Green
	filter_green();			// select green filter
	pulse = 0;				// reset the count to 0
	_delay_ms(100);			// capture the pulses for 100 ms or 0.1 second
	green = pulse;			// store the count in variable called green
}

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	// Blue
	filter_blue();			// select blue filter
	pulse = 0;				// reset the count to 0
	_delay_ms(100);			// capture the pulses for 100 ms or 0.1 second
	blue = pulse;			// store the count in variable called blue  
}

int main(void)
{
	init_devices();
	color_sensor_scaling();
  
	while(1)
	{
		// Write your code here
		red_read();
		green_read();
		blue_read();
		if((red < 3000) && (blue < 3000) && (green < 3000))
		{
			PORTA = 0x07;				// Switch off RGB LED in case of black detection
		}
		else if(red > green)
		{
			if(red > blue)
			{
				PORTA = 0x06;			// Glow only RED
			}
			else
			{
				PORTA = 0x03;			// Glow only BLUE
			}
		}
		else if(blue > green)
		{
			PORTA = 0x03;				// Glow only BLUE
		}
		else
		{
			PORTA = 0x05;				// Glow only GREEN
		}
	}
}